actions.c:		(data->select_keymap.std[input.value])(data, input);
actions.c:		(data->select_keymap.ctrl[(int)input.buf[2]])(data, input);
actions.c:		(data->cmd_keymap.std[input.value])(data, input);
actions.c:		(data->cmd_keymap.ctrl[(int)input.buf[2]])(data, input);
actions.c:	tputs(data->termcaps.vs, 1, output);
actions.c:	tputs(data->termcaps.vi, 0, output);
actions.c:	if (data->mode == SELECT)
actions.c:	else if (data->mode == COMMAN)
actions.c:	else if (data->mode == SEARCH)
bar.c:	tputs(tgoto(data->termcaps.cm, 0, data->win.ws_row), 1, output);
bar.c:	tputs(data->termcaps.ce, 1, output);
bar.c:	if (data->win.ws_col > 0)
bar.c:		ft_dprintf(data->fd, "%s%*s", BFIELD, data->win.ws_col, " ");
bar.c:	tputs(tgoto(data->termcaps.cm, 0, data->win.ws_row), 1, output);
bar.c:	e = data->elements;
bar.c:	if (data->win.ws_col >= 23)
bar.c:		ft_dprintf(data->fd, " %sSort:  %s  %s", BFIELD, data->sort->name, BFIELD); // len up to 25
bar.c:	if (data->win.ws_col >= 25 + 16)
bar.c:		ft_dprintf(data->fd, "    Selected:%3d", nb_selected(data)); // len up to 16
bar.c:	if (data->win.ws_col >= 25 + 16 + 55)
bar.c:		tputs(tgoto(data->termcaps.cm, data->win.ws_col - 55, data->win.ws_row), 1, output);
bar.c:		ft_dprintf(data->fd, "%s    Press <:> sort mode   </> search mode   <r> reset%s", GRMODE, DEFAULT); // len up to 55
bar.c:	if (data->win.ws_col >= 23)
bar.c:		ft_dprintf(data->fd, " %sSort:%s%s %s %s%s", BFIELD, RESFID, data->sort->prev ? ARLE : " ", data->sort->name, data->sort->next ? ARRI : " ", BFIELD);
bar.c:	if (data->win.ws_col >= 25 + 16)
bar.c:		ft_dprintf(data->fd, "    Selected:%3d", nb_selected(data));
bar.c:	if (data->win.ws_col >= 25 + 16 + 55) // limit is max len of help msg
bar.c:		ft_dprintf(data->fd, "%s    %sPress <ESC> or <ENTER> to quit mode%s", GRMODE, GRHELP, DEFAULT); // len up to 28
bar.c:	len_msg = data->win.ws_col < 26 ? data->win.ws_col : 26;
bar.c:	ft_dprintf(data->fd, "%s", SEAERR);
bar.c:	write(data->fd, "Search: Pattern not found", len_msg);
bar.c:	if (data->win.ws_col >= 28 + 1)
bar.c:		ft_dprintf(data->fd, ": %.*s", data->win.ws_col - 28, data->search_line);
bar.c:	ft_dprintf(data->fd, "%s", DEFAULT);
bar.c:	data->search_error = 1;
bar.c:	offset = data->sl_cpos + 2 - data->win.ws_col;
bar.c:		ft_dprintf(data->fd, "<");
bar.c:		ft_dprintf(data->fd, "/");
bar.c:	ft_dprintf(data->fd, "%.*s", data->win.ws_col - 2, &data->search_line[offset]);
bar.c:	if (offset + data->win.ws_col < data->sl_len + 2)
bar.c:		ft_dprintf(data->fd, ">");
bar.c:	ft_dprintf(data->fd, "%s", DEFAULT);
bar.c:	tputs(tgoto(data->termcaps.cm, data->sl_cpos - offset + 1, data->win.ws_row), 1, output);
bar.c:	tputs(tgoto(data->termcaps.cm, 0, data->win.ws_row), 1, output);
bar.c:	if (!data->search_error) // search line editing
bar.c:	if (data->mode == SELECT)
bar.c:	else if (data->mode == COMMAN)
bar.c:	else if (data->mode == SEARCH)
bar.c:	if (data->win.ws_row < 2)
bar.c:		data->bar_enabled = 0;
bar.c:		data->bar_enabled = 1;
command.c:	data->mode = COMMAN;
command.c:	data->no_refresh = 1;
display.c:	if (data->frame_enabled)
display.c:	l = data->elements;
display.c:		tputs(tgoto(data->termcaps.cm, w_frame + j, w_frame + i), 1, output);
display.c:		if (l == data->cursor)
display.c:				ft_printf("%s%s%.*s%s", l->color, UNDERL, data->win.ws_col - w_frame * 2, l->arg, DEFAULT);
display.c:				ft_printf("%s%s%.*s%s", HIGHLI, UNDERL, data->win.ws_col - w_frame * 2, l->arg, DEFAULT);
display.c:				ft_printf("%s%.*s%s", l->color, data->win.ws_col - w_frame * 2, l->arg, DEFAULT);
display.c:				ft_printf("%s%.*s%s", "\e[7m", data->win.ws_col - w_frame * 2, l->arg, DEFAULT);
display.c:		if (i >= data->win.ws_row - 3)
display.c:	tputs(tgoto(data->termcaps.cl, 0, 0), 1, output);
elements.c:	if (data->elements == NULL || data->cursor == NULL)
elements.c:	if (data->elements == data->cursor)
elements.c:		data->elements = data->cursor->next;
elements.c:	if (data->cursor->next != NULL)
elements.c:		data->cursor->next->previous = data->cursor->previous;
elements.c:	if (data->cursor->previous != NULL)
elements.c:		data->cursor->previous->next = data->cursor->next;
elements.c:	free(data->cursor);
elements.c:	data->cursor = NULL;
elements.c:	if (!data->elements)
elements.c:		data->elements = node_element(NULL, av);
elements.c:		last = data->elements;
frame.c:	tputs(tgoto(data->termcaps.cm, 0, 0), 1, output);
frame.c:	ft_dprintf(data->fd, "┌");
frame.c:	while (++i < data->win.ws_col - 1)
frame.c:		ft_dprintf(data->fd, "─");
frame.c:	ft_dprintf(data->fd, "┐");
frame.c:	while (++i < data->win.ws_row - 2)
frame.c:		tputs(tgoto(data->termcaps.cm, 0, i), 1, output);
frame.c:		ft_dprintf(data->fd, "│");
frame.c:		tputs(tgoto(data->termcaps.cm, data->win.ws_col, i), 1, output);
frame.c:		ft_dprintf(data->fd, "│");
frame.c:	tputs(tgoto(data->termcaps.cm, 0, data->win.ws_row - 2), 1, output);
frame.c:	ft_dprintf(data->fd, "└");
frame.c:	while (++i < data->win.ws_col - 1)
frame.c:		ft_dprintf(data->fd, "─");
frame.c:	ft_dprintf(data->fd, "┘");
frame.c:	if (data->win.ws_row < 4 || data->win.ws_col < 3)
frame.c:		data->frame_enabled = 0; // Not enough space to display frame and bar and an element
frame.c:		data->frame_enabled = 1;
io.c:	if (write(data->fd, &c, sizeof(c)) != -1)
io.c:        tputs(tgoto(data->termcaps.cm , col, row), 1, output);
io.c:        write(data->fd, l->arg, l->len);
keymap.c:	data->no_refresh = 1;
keymap.c:	data->select_keymap.ctrl[65] = &cursor_prev; // prev element up
keymap.c:	data->select_keymap.ctrl[66] = &cursor_next; // next element down
keymap.c:	data->select_keymap.ctrl[51] = &del_cursor_element;
keymap.c:	data->select_keymap.std[27] = &quit;
keymap.c:	data->select_keymap.std[' '] = &select_it;
keymap.c:	data->select_keymap.std[':'] = &set_command_mode;
keymap.c:	data->select_keymap.std['/'] = &set_search_mode;
keymap.c:	data->cmd_keymap.ctrl[67] = &right_sort_mode;
keymap.c:	data->cmd_keymap.ctrl[68] = &left_sort_mode;
keymap.c:	data->cmd_keymap.std[27] = &set_select_mode;
keymap.c:		data->select_keymap.std[i] = &none;
keymap.c:		data->select_keymap.ctrl[i] = &none;
keymap.c:		data->select_keymap.meta[i] = &none;
keymap.c:		data->cmd_keymap.std[i] = &none;
keymap.c:		data->cmd_keymap.ctrl[i] = &none;
keymap.c:		data->cmd_keymap.meta[i] = &none;
keymap.c:		data->search_keymap.std[i] = &none;
keymap.c:		data->search_keymap.ctrl[i] = &none;
keymap.c:		data->search_keymap.meta[i] = &none;
main.c:		data->cursor = data->elements;
main.c:			if (!data->no_refresh)
main.c:			data->no_refresh = 0;
page.c:	if (data->frame_enabled)
page.c:		capacity = data->win.ws_row - 3;
page.c:		nmax = data->win.ws_row - 1;
page.c:	if (data->frame_enabled)
page.c:		remaining_width = data->win.ws_col - 3;
page.c:		remaining_width = data->win.ws_col - 1;
page.c:	e = data->elements;
page.c:	data->elements->page = 1;
page.c:	data->psum = 10; // SHoud be computed at each resize
page.c:	data->pnb = 1; // SHould be computed what element is underlined
page.c:	if (data->psum > 1 && data->frame_enabled && data->win.ws_col > 10) // No need to display pages if only 1 page
page.c:		tputs(tgoto(data->termcaps.cm, data->win.ws_col / 2 - 5, data->win.ws_row - 2), 1, output);
page.c:		ft_dprintf(data->fd, "%3d/%-3d", data->pnb, data->psum);
search.c:	data->mode = SEARCH;
select.c:	if (lastsort == data->sort)
select.c:		data->no_refresh = 1;
select.c:	data->mode = SELECT;
select.c:	data->search_error = 0;
select.c:	if (data->cursor->previous)
select.c:		data->cursor = data->cursor->previous;
select.c:		while (data->cursor->next)
select.c:			data->cursor = data->cursor->next;
select.c:	data->no_refresh = 1;
select.c:	if (data->cursor->next)
select.c:		data->cursor = data->cursor->next;
select.c:		data->cursor = data->elements;
select.c:	data->no_refresh = 1;
select.c:	if (data->cursor)
select.c:		data->cursor->selected ^= 1;
select.c:	if (data->cursor->next)
select.c:		e = data->cursor->next;
select.c:	else if (data->cursor->previous)
select.c:		e = data->cursor->previous;
select.c:	data->cursor = e;
select.c:	if (!data->cursor)
selection.c:	while (data->elements)
selection.c:		if (!has_prev && data->elements->selected)
selection.c:			ft_printf("%s", data->elements->arg);
selection.c:		else if (has_prev && data->elements->selected)
selection.c:			ft_printf(" %s", data->elements->arg);
selection.c:		data->elements = data->elements->next;
sort.c:	data->sort = &alpha;
sort.c:	if (data->sort->next)
sort.c:		data->sort = data->sort->next;
sort.c:	data->no_refresh = 1;
sort.c:	if (data->sort->prev)
sort.c:		data->sort = data->sort->prev;
sort.c:	data->no_refresh = 1;
sort.c:	if (data->sort->fcmp(*e1, *e2) > 0)
sort.c:	if (data && data->elements && data->elements->next)
sort.c:		ft_merge_sort(&data->elements, data);
sort.c:	e = data->elements;
sort.c:	data->elements->previous = NULL;
terminal.c:	if (ioctl(STDERR_FILENO, TIOCGWINSZ, &(data->win)) == -1)
terminal.c:	if (!(data->termcaps.cl = tgetstr("cl", NULL))
terminal.c:		|| !(data->termcaps.ce = tgetstr("ce", NULL))
terminal.c:		|| !(data->termcaps.vs = tgetstr("vs", NULL))
terminal.c:		|| !(data->termcaps.vi = tgetstr("vi", NULL))
terminal.c:		|| !(data->termcaps.us = tgetstr("us", NULL))
terminal.c:		|| !(data->termcaps.af = tgetstr("AF", NULL))
terminal.c:		|| !(data->termcaps.ab = tgetstr("AB", NULL))
terminal.c:		|| !(data->termcaps.cm = tgetstr("cm", NULL))
terminal.c:		|| !(data->termcaps.me = tgetstr("me", NULL))
terminal.c:		|| !(data->termcaps.ti = tgetstr("ti", NULL))
terminal.c:		|| !(data->termcaps.te = tgetstr("te", NULL)))
terminal.c:			data->dumb_mode = 1;
terminal.c:		data->ttyname = ttyname(STDIN_FILENO);
terminal.c:		if (data->ttyname)
terminal.c:			data->fd = open(data->ttyname, O_RDWR);
terminal.c:		if (data->fd == -1)
terminal.c:		data->term = getenv("TERM");
terminal.c:		if (!data->term)
terminal.c:			data->term = "dumb";
terminal.c:		if (tgetent(NULL, data->term) != 1)
terminal.c:	if (data->dumb_mode) // Should be removed once dumb_mode is handled
terminal.c:	tcgetattr(STDOUT_FILENO, &(data->termios_backup));
terminal.c:	tcgetattr(STDOUT_FILENO, &(data->termios_select));
terminal.c:	data->termios_select.c_lflag &= ~(ICANON | ECHO);
terminal.c:	data->termios_select.c_cc[VMIN] = 1;
terminal.c:	data->termios_select.c_cc[VTIME] = 0;
terminal.c:	data->termios_select.c_iflag &= ~(INLCR);
terminal.c:	tcsetattr(STDOUT_FILENO, TCSAFLUSH, &(data->termios_select));
terminal.c:	tputs(data->termcaps.ti, 1, output);
terminal.c:	tputs(data->termcaps.vi, 1, output);
terminal.c:	tputs(data->termcaps.vs, 1, output);
terminal.c:	tputs(data->termcaps.te, 1, output);
terminal.c:	close(data->fd);
terminal.c:	tcsetattr(STDIN_FILENO, TCSAFLUSH, &(data->termios_backup));
